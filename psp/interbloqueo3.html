<!DOCTYPE html>
<html>
<head>
<style>
body { 
    font-family: Arial, sans-serif;
    line-height: 1.6;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}
code {
    background-color: #f4f4f4;
    padding: 2px 4px;
    border-radius: 4px;
}
pre {
    background-color: #f4f4f4;
    padding: 15px;
    border-radius: 8px;
    overflow-x: auto;
}
</style>
</head>
<body>

<h3>Ejemplo de simulación de paso por puente</h3>

<p>El siguiente programa de ejemplo simula un sistema que controla el paso de personas por un puente, siempre en la misma dirección, para que se cumplan las siguientes restricciones. No pueden pasar más de tres personas a la vez, y no puede haber más de 200 kg de peso en ningún momento. Para realizar la simulación, se modelan las personas como hilos. El tiempo entre la llegada de dos personas es aleatorio entre 1 y 30 s, y para atravesar el puente aleatorio, entre 10 y 50 s. Las personas tienen un peso aleatorio de entre 40 y 120 kg.</p>

<p>En un objeto de la clase Puente se guarda el estado compartido por todos los hilos: el número de personas que están cruzando el puente y el peso total. Este objeto se pasa a todos los hilos de la clase Persona, en su constructor. Estos lo utilizan como como objeto de bloqueo. En esta clase, y esto es importante, se almacena este objeto en una variable de referencia de tipo final. Todos los métodos de esta clase que consultan o modifican su estado son synchronized. Para simplificar la programación, tiene un método autorizacionPaso que verifica si se cumplen las condiciones para que una persona entre en el puente y, si es así, actualiza su estado. Se invoca este método en un bloque synchronized sobre el propio objeto. El método terminaPaso también se invoca en un bloque sincronizado sobre el propio objeto, y después se llama a notifyAll, para dar la opción de entrar al puente a personas que estén esperando. Con notify se daría opción a una como máximo, lo que sería demasiado restrictivo, porque la salida de una persona podría permitir el paso de más de una.</p>
<p>La simulación se hace en tiempo real, pero no tiene por qué ser así. Es decir, las esperas en la simulación no tienen por qué ser iguales a las esperas en la realidad. Pero sí hay que guardar la proporcionalidad. Por ejemplo, podrían no multiplicarse los tiempos en milisegundos por mil, o multiplicarse por un factor distinto, pero hay que hacerlo siempre por el mismo.</p>

<pre><code>
import java.util.Random;

class Puente {    // Estado, objeto compartido entre los hilos
    private static final int PESO_MAXIMO = 200;
    private static final int MAX_PERSONAS = 3;
    private int peso = 0;
    private int numPersonas = 0;

    synchronized public int getPeso() {
        return peso;
    }

    synchronized public int getNumPersonas() {
        return numPersonas;
    }

    synchronized public boolean autorizacionPaso(Persona persona) {
        boolean result;
        if (this.peso + persona.getPeso() <= Puente.PESO_MAXIMO &&
            this.numPersonas < Puente.MAX_PERSONAS) {
            this.numPersonas++;
            this.peso += persona.getPeso();
            result = true;
        } else {
            result = false;
        }
        return result;
    }

    synchronized public void terminaPaso(Persona persona) {
        this.peso -= persona.getPeso();
        this.numPersonas--;
    }
}

class Persona implements Runnable {
    private final String idPersona;
    private final int peso;
    private final int tMinPaso, tMaxPaso;
    private final Puente puente;

    public int getPeso() {
        return peso;
    }

    Persona(Puente puente, int peso, int tMinPaso, int tMaxPaso, String idP) {
        this.puente = puente;
        this.peso = peso;
        this.tMinPaso = tMinPaso;
        this.tMaxPaso = tMaxPaso;
        this.idPersona = idP;
    }

    @Override
    public void run() {
        System.out.printf(
            "_ %s de %d kg quiere cruzar, en puente %d kg, %d persona%s.\n",
            this.idPersona, this.peso, puente.getPeso(), puente.getNumPersonas(),
            puente.getNumPersonas() != 1 ? "s" : "");

        // Espera para conseguir autorización
        boolean autorizado = false;
        while (!autorizado) {
            synchronized (this.puente) {
                autorizado = this.puente.autorizacionPaso(this);
                if (!autorizado) {
                    try {
                        System.out.printf("# %s debe esperar.\n", this.idPersona);
                        this.puente.wait();
                    } catch (InterruptedException ex) {
                        System.out.printf("Interrupción mientras %s espera.\n",
                            this.idPersona);
                    }
                }
            }
        }

        System.out.printf(
            "> %s con peso %d puede cruzar, peso en puente %d con %d persona%s.\n",
            this.idPersona, this.getPeso(), this.puente.getPeso(),
            puente.getNumPersonas(), puente.getNumPersonas() != 1 ? "s":"");

        Random r = new Random();    // Pasa el puente, y tarda un tiempo en cruzar
        int tiempoPaso = this.tMinPaso+r.nextInt(this.tMaxPaso-this.tMinPaso+1);
        try {
            System.out.printf("%s va a tardar tiempo %d en cruzar.\n",
                this.idPersona, tiempoPaso);
            Thread.sleep(1000*tiempoPaso);
        } catch (InterruptedException ex) {
            System.out.printf("Interrupción mientras %s pasa.\n", this.idPersona);
        }

        // Sale del puente
        synchronized (this.puente) {
            this.puente.terminaPaso(this);
            System.out.printf(
                "< %s sale del puente, puente soporta peso %d, %d persona%s.\n",
                this.idPersona, this.puente.getPeso(), this.puente.getNumPersonas(),
                this.puente.getNumPersonas() != 1 ? "s" : "");
            puente.notifyAll();
        }
    }
}

public class PasoPorPuente {
    public static void main(String[] args) {
        final Puente puente = new Puente();

        int tMinParaLlegadaPersona = 1;
        int tMaxParaLlegadaPersona = 30;
        int tMinPaso = 10;
        int tMaxPaso = 50;
        int minPesoPersona = 40;
        int maxPesoPersona = 120;

        System.out.println(">>>>>>>>>>>>> Comienza simulación.");
        Random r = new Random();
        int idPersona = 1;
        while (true) {
            int tParaLlegadaPersona = tMinParaLlegadaPersona + r.nextInt(
                tMaxParaLlegadaPersona - tMinParaLlegadaPersona + 1);
            int pesoPersona = minPesoPersona + r.nextInt(
                maxPesoPersona - minPesoPersona + 1);

            System.out.printf("Siguiente persona llega en %d segundos.\n",
                tParaLlegadaPersona);
            try {
                Thread.sleep(1000*tParaLlegadaPersona);
            } catch (InterruptedException ex) {
                System.out.println("Interrumpido proceso principal");
            }

            Thread hiloPersona = new Thread(new Persona(
                puente, pesoPersona, tMinPaso, tMaxPaso, "P"+idPersona));
            hiloPersona.start();

            idPersona++;
        }
    }
}</code></pre>
</body>
</html>