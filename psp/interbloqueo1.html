<!DOCTYPE html>
<html>
<head>
<style>
body { 
    font-family: Arial, sans-serif;
    line-height: 1.6;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}
code {
    background-color: #f4f4f4;
    padding: 2px 4px;
    border-radius: 4px;
}
pre {
    background-color: #f4f4f4;
    padding: 15px;
    border-radius: 8px;
    overflow-x: auto;
}
</style>
</head>
<body>


<h2>Compartición de recursos con bloqueo dependiente de su estado</h2>

<p>En el apartado anterior se ha visto un tipo de problemas en que varios hilos comparten recursos. Estos recursos podrían ser, sencillamente, objetos cuyo estado puede ser actualizado por cualquiera de esos hilos y una vez conseguido el acceso en exclusiva a estos recursos, mediante objetos de bloqueo, se pueden realizar determinadas operaciones, independientemente de ninguna información de estado. En este apartado se estudia otro tipo de problemas en los que, dependiendo del estado de los recursos, cada uno de los hilos podrá realizar determinadas acciones o no. Y en este último caso, podrá quedar a la espera de que se produzca un cambio de estado, del que será notificado por otros hilos.</p>

<p>Para ello, además de un mecanismo de bloqueo sobre los recursos (objetos) compartidos, será necesario un mecanismo de espera para que, en el caso de que el estado de los recursos compartidos no permita que se realice una operación, la ejecución del hilo quede en suspenso a la espera de que esa condición se cumpla. Y debe ser un mecanismo de espera no activa. Es decir, no se debe consumir tiempo del procesador ni recursos del sistema para comprobar si es posible continuar con la ejecución, mientras no se reciba una notificación de que el estado ha cambiado y podría permitir que el hilo continúe su ejecución.</p>

<p>Para este tipo de problemas, se utilizan varios métodos que se pueden ejecutar sólo en un bloque de código synchronized, y sobre el objeto de bloqueo para el bloque de código.</p>

<ul>
    <li>wait() interrumpe la ejecución del hilo actual. La ejecución del hilo queda bloqueada mientras otro hilo no ejecute el método notify() o el método notifyAll() sobre el objeto. Este método, por tanto, proporciona un mecanismo de espera no activa.</li>
    <li>notify() desbloquea uno de los hilos que están esperando sobre el objeto tras haber ejecutado el método wait(), de manera que pueda continuar su ejecución. Este método, por tanto, proporciona un mecanismo de notificación para terminar con la espera no activa de los hilos que están a la espera en un objeto de bloqueo. El orden en que se desbloquean los hilos en un objeto de bloqueo no tiene por qué ser el mismo en que se bloquearon.</li>
    <li>notifyAll() desbloquea todos los hilos que están esperando sobre el objeto de bloqueo tras haber ejecutado el método wait(), de manera que puedan continuar su ejecución.</li>
</ul>

<p>Estos métodos se utilizan cuando un hilo puede realizar o no una operación dependiendo del estado del sistema. La verificación de ese estado debe hacerse dentro de un método synchronized. Si, de acuerdo con el estado del sistema, no es posible realizar la operación, se ejecuta el método wait() sobre el objeto de bloqueo. Un hilo que cambia el estado del sistema, de manera que podrían continuar otros hilos que han quedado en suspenso tras realizar la operación wait(), ejecuta uno de los métodos notify() o notifyAll() sobre el objeto de bloqueo. Esto permite continuar a uno de los hilos bloqueados en el objeto de bloqueo (en el caso de notify()) o a todos (en el caso de notifyAll()).</p>

<pre><code>synchronized (objetoBloqueo) {     // Acceso a recurso con exclusión mutua
    while (!condicionParaOperacion) { // Depende de estado de objetoBloqueo
        try {
            objetoBloqueo.wait();  // Espera que alguien cambie estado y notifique
        } catch(InterruptedException ex) {
        }
    }
    // Se puede realizar operación.
    // No puede interferir otro hilo desde comprobación de condición
    // en while(), porque todo esto está dentro de un bucle synchronized,
    // en el que solo se cede el control con wait()

    realizar_operacion;

    // Si como consecuencia de realizar la operación pudiera continuar
    // otro hilo, habría que hacer objetoBloqueo.notifyAll()
    // u objetoBloqueo.notify()
}</code></pre>

<p>Por otra parte, es habitual que objetoBloqueo sea un objeto que contiene el estado compartido por todos los hilos, y sobre el que se puede decidir si distintas operaciones se pueden o no realizar. Por lo tanto, y más específicamente, un esquema típico para los distintos hilos de un programa sería el siguiente:</p>

<pre><code>synchronized (objetoEstado) {    // Se comprueba con métodos de objetoEstado
    try {
        while(!condicionParaOperacion) {
            objetoEstado.wait();   // Espera que alguien cambie estado y avise
        }
    } catch(InterruptedException ex) {
    }
    // Se puede realizar operación.
    realizar_operacion;            // Normalmente modifica objetoEstado
    if (condicionParaQueSiganOtros) { // Se verifica con métodos de objetoEstado
        objetoEstado.notifyAll();
    }
}</code></pre>

</body>
</html>