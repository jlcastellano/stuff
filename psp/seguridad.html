<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Seguridad, Criptografía y TLS/SSL en Java</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                line-height: 1.6;
                margin: 0;
                padding: 20px;
                max-width: 1200px;
                margin: 0 auto;
                color: #333;
            }
    
            h1, h2, h3 {
                color: #2c3e50;
            }
    
            .container {
                background-color: #f9f9f9;
                padding: 20px;
                border-radius: 5px;
                margin-bottom: 20px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
    
            .intro-box {
                background-color: #e3f2fd;
                padding: 20px;
                border-radius: 5px;
                margin-bottom: 20px;
                border-left: 5px solid #1976d2;
            }
    
            .tls-box {
                background-color: #f3e5f5;
                padding: 20px;
                border-radius: 5px;
                margin-bottom: 20px;
                border-left: 5px solid #7b1fa2;
            }
    
            .cert-box {
                background-color: #e8f5e9;
                padding: 20px;
                border-radius: 5px;
                margin-bottom: 20px;
                border-left: 5px solid #388e3c;
            }
    
            .handshake-box {
                background-color: #fff3e0;
                padding: 20px;
                border-radius: 5px;
                margin-bottom: 20px;
                border-left: 5px solid #e65100;
            }
    
            pre {
                background-color: #f1f1f1;
                padding: 15px;
                border-radius: 5px;
                overflow-x: auto;
            }
    
            code {
                font-family: 'Courier New', Courier, monospace;
            }
    
            .warning {
                background-color: #fff3cd;
                border-left: 5px solid #ffc107;
                padding: 10px;
                margin: 10px 0;
            }
    
            .danger {
                background-color: #f8d7da;
                border-left: 5px solid #dc3545;
                padding: 10px;
                margin: 10px 0;
            }
    
            table {
                width: 100%;
                border-collapse: collapse;
                margin: 20px 0;
            }
    
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
    
            th {
                background-color: #f5f5f5;
            }
    
            @media (max-width: 768px) {
                body {
                    padding: 10px;
                }
                pre {
                    font-size: 14px;
                }
            }
    
            .diagram {
                font-family: monospace;
                white-space: pre;
                padding: 20px;
                background-color: #f8f9fa;
                border-radius: 5px;
            }
            .explanation-box {
                background-color: #f8f9fa;
                border-left: 5px solid #0d6efd;
                padding: 15px;
                margin-bottom: 20px;
                border-radius: 0 5px 5px 0;
            }
            
            .explanation-box h4 {
                color: #0d6efd;
                margin-top: 10px;
                margin-bottom: 5px;
            }
            
            .explanation-box ul, .explanation-box ol {
                margin-top: 5px;
                margin-bottom: 10px;
                padding-left: 25px;
            }
        </style>
    </head>
<body>
    <h1>Seguridad General en Java</h1>

    <div class="intro-box">
        <h2>Introducción a la Seguridad en Aplicaciones</h2>
        <p>La seguridad en aplicaciones Java requiere un enfoque multicapa que abarca autenticación, autorización, protección de datos, y prevención de ataques comunes.</p>
    </div>

    <!-- Gestión de Sesiones -->
         <div class="container">
        <h3>Gestión de Sesiones</h3>
        
        <div class="explanation-box">
            <h4>Qué es:</h4>
            <p>Sistema que gestiona estados temporales y seguros para cada usuario que interactúa con la aplicación, manteniendo su información y estado de autenticación entre diferentes peticiones.</p>
            
            <h4>Por qué es necesario:</h4>
            <ul>
                <li>Mantener el estado del usuario entre peticiones</li>
                <li>Controlar el tiempo de vida de las sesiones</li>
                <li>Prevenir accesos no autorizados</li>
                <li>Gestionar el cierre de sesión</li>
            </ul>
            
            <h4>Funcionamiento:</h4>
            <ol>
                <li>Cuando un usuario inicia sesión, se crea una sesión única con generateSessionId()</li>
                <li>La sesión almacena ID de usuario y timestamp de creación/último acceso</li>
                <li>Se verifica la validez de la sesión en cada petición</li>
                <li>Las sesiones inactivas por más de 30 minutos son invalidadas automáticamente</li>
            </ol>
        </div>
        <pre><code>
public class SessionManager {
    private static final int SESSION_TIMEOUT = 30 * 60; // 30 minutos
    private static final Map<String, Session> sessions = new ConcurrentHashMap<>();

    public static class Session {
        private final String id;
        private final String userId;
        private final Map<String, Object> attributes;
        private final long creationTime;
        private long lastAccessTime;

        public Session(String userId) {
            this.id = generateSessionId();
            this.userId = userId;
            this.attributes = new ConcurrentHashMap<>();
            this.creationTime = System.currentTimeMillis();
            this.lastAccessTime = this.creationTime;
        }

        private String generateSessionId() {
            return UUID.randomUUID().toString() + 
                   SecureRandomUtil.generateToken(32);
        }
    }

    public static Session createSession(String userId) {
        Session session = new Session(userId);
        sessions.put(session.id, session);
        return session;
    }

    public static void invalidateSession(String sessionId) {
        sessions.remove(sessionId);
    }

    public static boolean isValidSession(String sessionId) {
        Session session = sessions.get(sessionId);
        if (session == null) return false;

        long currentTime = System.currentTimeMillis();
        if (currentTime - session.lastAccessTime > SESSION_TIMEOUT * 1000) {
            invalidateSession(sessionId);
            return false;
        }

        session.lastAccessTime = currentTime;
        return true;
    }
}
        </code></pre>
    </div>

    <!-- Control de Acceso Basado en Roles -->
    <div class="container">
        <h3>Control de Acceso Basado en Roles (RBAC)</h3>
        
        <div class="explanation-box">
            <h4>Qué es:</h4>
            <p>Sistema de autorización que controla el acceso a recursos y funcionalidades basado en roles asignados a usuarios y sus permisos asociados.</p>
            
            <h4>Por qué es necesario:</h4>
            <ul>
                <li>Implementar el principio de mínimo privilegio</li>
                <li>Controlar acceso a recursos y funcionalidades</li>
                <li>Mantener separación de responsabilidades</li>
                <li>Facilitar la gestión de permisos</li>
            </ul>
            
            <h4>Funcionamiento:</h4>
            <ol>
                <li>Los usuarios tienen roles asignados (ej: ADMIN, USER)</li>
                <li>Los roles tienen permisos asociados</li>
                <li>Se verifica si un usuario tiene permiso antes de cada operación protegida</li>
                <li>Permite verificación granular de permisos</li>
            </ol>
        </div>
        <pre><code>
public class RBACManager {
    private static final Map<String, Set<String>> userRoles = new ConcurrentHashMap<>();
    private static final Map<String, Set<String>> rolePermissions = new ConcurrentHashMap<>();

    public static void addUserRole(String userId, String role) {
        userRoles.computeIfAbsent(userId, k -> new HashSet<>()).add(role);
    }

    public static void addRolePermission(String role, String permission) {
        rolePermissions.computeIfAbsent(role, k -> new HashSet<>()).add(permission);
    }

    public static boolean hasPermission(String userId, String permission) {
        Set<String> roles = userRoles.get(userId);
        if (roles == null) return false;

        return roles.stream()
            .anyMatch(role -> {
                Set<String> permissions = rolePermissions.get(role);
                return permissions != null && permissions.contains(permission);
            });
    }

    @FunctionalInterface
    public interface SecuredOperation {
        void execute() throws SecurityException;
    }

    public static void requirePermission(String userId, String permission, 
            SecuredOperation operation) {
        if (!hasPermission(userId, permission)) {
            throw new SecurityException("Access denied");
        }
        operation.execute();
    }
}
        </code></pre>
    </div>

   <!-- Prevención de XSS -->
   <div class="container">
    <h3>Prevención de XSS</h3>
    
    <div class="explanation-box">
        <h4>Qué es:</h4>
        <p>Sistema de defensa que previene la inyección y ejecución de scripts maliciosos en páginas web a través de la sanitización y codificación de datos.</p>
        
        <h4>Por qué es necesario:</h4>
        <ul>
            <li>Evitar la inyección de scripts maliciosos</li>
            <li>Proteger datos sensibles del usuario</li>
            <li>Mantener la integridad de la aplicación</li>
            <li>Cumplir con estándares de seguridad</li>
        </ul>
        
        <h4>Funcionamiento:</h4>
        <ol>
            <li>Sanitiza entrada de usuario eliminando código malicioso</li>
            <li>Codifica caracteres especiales en HTML</li>
            <li>Escapa contenido JavaScript</li>
            <li>Filtra URLs para prevenir redirecciones maliciosas</li>
        </ol>
    </div>
        <pre><code>
public class XSSPrevention {
    public static String sanitizeHTML(String input) {
        return Encode.forHtml(input);
    }

    public static String sanitizeJavaScript(String input) {
        return Encode.forJavaScript(input);
    }

    public static String sanitizeURL(String input) {
        return Encode.forUri(input);
    }

    public static class XSSFilter implements Filter {
        @Override
        public void doFilter(ServletRequest request, ServletResponse response,
                FilterChain chain) throws IOException, ServletException {
            HttpServletRequest httpRequest = (HttpServletRequest) request;
            XSSRequestWrapper wrapper = new XSSRequestWrapper(httpRequest);
            chain.doFilter(wrapper, response);
        }
    }
}
        </code></pre>
    </div>

    <!-- Prevención de CSRF -->
    <div class="container">
        <h3>Prevención de CSRF</h3>
        
        <div class="explanation-box">
            <h4>Qué es:</h4>
            <p>Sistema de protección que verifica la autenticidad de las peticiones HTTP para prevenir ataques de falsificación de peticiones entre sitios.</p>
            
            <h4>Por qué es necesario:</h4>
            <ul>
                <li>Prevenir ataques de falsificación de peticiones</li>
                <li>Verificar autenticidad de las peticiones</li>
                <li>Proteger operaciones que modifican datos</li>
                <li>Asegurar que las peticiones provienen de fuentes legítimas</li>
            </ul>
            
            <h4>Funcionamiento:</h4>
            <ol>
                <li>Genera token único por sesión</li>
                <li>Incluye token en formularios/headers</li>
                <li>Valida token en cada petición que modifica estado</li>
                <li>Rechaza peticiones sin token válido</li>
            </ol>
        </div>
        <pre><code>
public class CSRFProtection {
    private static final int TOKEN_LENGTH = 32;

    public static String generateToken() {
        return SecureRandomUtil.generateToken(TOKEN_LENGTH);
    }

    public static boolean validateToken(String sessionToken, String requestToken) {
        if (sessionToken == null || requestToken == null) {
            return false;
        }
        return MessageDigest.isEqual(
            sessionToken.getBytes(),
            requestToken.getBytes()
        );
    }

    public static class CSRFFilter implements Filter {
        @Override
        public void doFilter(ServletRequest request, ServletResponse response,
                FilterChain chain) throws IOException, ServletException {
            HttpServletRequest httpRequest = (HttpServletRequest) request;
            HttpServletResponse httpResponse = (HttpServletResponse) response;

            if (isStateChangingMethod(httpRequest.getMethod())) {
                String sessionToken = (String) httpRequest.getSession()
                    .getAttribute("csrf_token");
                String requestToken = httpRequest.getHeader("X-CSRF-TOKEN");

                if (!validateToken(sessionToken, requestToken)) {
                    httpResponse.sendError(HttpServletResponse.SC_FORBIDDEN,
                        "CSRF token validation failed");
                    return;
                }
            }

            chain.doFilter(request, response);
        }

        private boolean isStateChangingMethod(String method) {
            return "POST".equals(method) || "PUT".equals(method) || 
                   "DELETE".equals(method) || "PATCH".equals(method);
        }
    }
}
        </code></pre>
    </div>

    <!-- SQL Injection Prevention -->
    <div class="container">
        <h3>Prevención de SQL Injection</h3>
        
        <div class="explanation-box">
            <h4>Qué es:</h4>
            <p>Sistema de seguridad que protege la base de datos contra ataques de inyección SQL mediante el uso de consultas parametrizadas y validación de entradas.</p>
            
            <h4>Por qué es necesario:</h4>
            <ul>
                <li>Proteger la base de datos</li>
                <li>Prevenir acceso no autorizado a datos</li>
                <li>Mantener la integridad de las consultas</li>
                <li>Evitar manipulación maliciosa de datos</li>
            </ul>
            
            <h4>Funcionamiento:</h4>
            <ol>
                <li>Usa PreparedStatements para todas las consultas</li>
                <li>Parametriza valores en las consultas SQL</li>
                <li>Evita concatenación directa de strings en queries</li>
                <li>Separa la lógica SQL de los datos de entrada</li>
            </ol>
        </div>
        <pre><code>
public class SQLInjectionPrevention {
    public static PreparedStatement createSafeStatement(Connection conn, 
            String sql, Object... params) throws SQLException {
        PreparedStatement stmt = conn.prepareStatement(sql);
        for (int i = 0; i < params.length; i++) {
            stmt.setObject(i + 1, params[i]);
        }
        return stmt;
    }

    // Ejemplo de uso seguro
    public User findUser(Connection conn, String username) throws SQLException {
        String sql = "SELECT * FROM users WHERE username = ?";
        try (PreparedStatement stmt = createSafeStatement(conn, sql, username)) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return new User(
                    rs.getLong("id"),
                    rs.getString("username"),
                    rs.getString("email")
                );
            }
            return null;
        }
    }
}
        </code></pre>
    </div>

    <!-- Logging Seguro -->
    <div class="container">
        <h3>Logging Seguro</h3>
        
        <div class="explanation-box">
            <h4>Qué es:</h4>
            <p>Sistema de registro que documenta eventos y acciones en la aplicación de manera segura, protegiendo información sensible y facilitando la auditoría.</p>
            
            <h4>Por qué es necesario:</h4>
            <ul>
                <li>Registrar eventos de seguridad</li>
                <li>Auditar acciones de usuarios</li>
                <li>Detectar actividades sospechosas</li>
                <li>Proteger información sensible en logs</li>
            </ul>
            
            <h4>Funcionamiento:</h4>
            <ol>
                <li>Filtra información sensible (contraseñas, tarjetas)</li>
                <li>Registra eventos con timestamp y contexto</li>
                <li>Mantiene logs de auditoría separados</li>
                <li>Implementa diferentes niveles de logging</li>
            </ol>
        </div>
        <pre><code>
public class SecureLogger {
    private static final Logger logger = LoggerFactory.getLogger(SecureLogger.class);
    private static final Pattern SENSITIVE_DATA = 
        Pattern.compile("\\b(password|credit_card|ssn)\\b", 
        Pattern.CASE_INSENSITIVE);

    public static void logInfo(String message) {
        logger.info(sanitizeLog(message));
    }

    public static void logError(String message, Throwable error) {
        logger.error(sanitizeLog(message), error);
    }

    private static String sanitizeLog(String message) {
        if (message == null) return null;
        return SENSITIVE_DATA.matcher(message).replaceAll("[REDACTED]");
    }

    public static void auditLog(String userId, String action, String resource) {
        String logMessage = String.format(
            "User: %s, Action: %s, Resource: %s, Time: %s, IP: %s",
            userId, action, resource, 
            LocalDateTime.now(), getCurrentIP()
        );
        logger.info("AUDIT: " + logMessage);
    }
}
        </code></pre>
    </div>

    <!-- Gestión de Secretos -->
    <div class="container">
        <h3>Gestión de Secretos</h3>
        
        <div class="explanation-box">
            <h4>Qué es:</h4>
            <p>Sistema especializado en el manejo seguro de información confidencial y credenciales, garantizando su protección en memoria y almacenamiento.</p>
            
            <h4>Por qué es necesario:</h4>
            <ul>
                <li>Proteger credenciales y claves</li>
                <li>Gestionar secretos de forma segura</li>
                <li>Limpiar datos sensibles de memoria</li>
                <li>Prevenir fugas de información</li>
            </ul>
            
            <h4>Funcionamiento:</h4>
            <ol>
                <li>Almacena secretos en arrays de caracteres</li>
                <li>Limpia memoria después de usar secretos</li>
                <li>Implementa AutoCloseable para limpieza automática</li>
                <li>Maneja lectura/escritura segura de secretos</li>
            </ol>
        </div>
        <pre><code>
public class SecretManager {
    private static final char[] EMPTY_CHAR_ARRAY = new char[0];
    
    public static class Secret implements AutoCloseable {
        private char[] value;

        public Secret(char[] value) {
            this.value = Arrays.copyOf(value, value.length);
            Arrays.fill(value, '\0'); // Limpiar el array original
        }

        public char[] getValue() {
            return Arrays.copyOf(value, value.length);
        }

        @Override
        public void close() {
            if (value != null) {
                Arrays.fill(value, '\0');
                value = null;
            }
        }
    }

    public static Secret loadSecret(String path) throws IOException {
        try (BufferedReader reader = new BufferedReader(
                new FileReader(path))) {
            String line = reader.readLine();
            if (line == null) {
                return new Secret(EMPTY_CHAR_ARRAY);
            }
            char[] secret = line.toCharArray();
            return new Secret(secret);
        }
    }

    public static void saveSecret(String path, char[] secret) 
            throws IOException {
        try (FileWriter writer = new FileWriter(path)) {
            writer.write(secret);
        } finally {
            Arrays.fill(secret, '\0');
        }
    }
}
        </code></pre>
    </div>

    <!-- Headers de Seguridad HTTP -->
    <div class="container">
        <h3>Configuración de Headers HTTP</h3>
        
        <div class="explanation-box">
            <h4>Qué es:</h4>
            <p>Sistema de configuración de cabeceras HTTP que implementa políticas de seguridad a nivel de navegador y protege contra ataques comunes basados en web.</p>
            
            <h4>Por qué es necesario:</h4>
            <ul>
                <li>Implementar defensas en el navegador</li>
                <li>Prevenir ataques comunes</li>
                <li>Configurar políticas de seguridad</li>
                <li>Reforzar la seguridad del cliente</li>
            </ul>
            
            <h4>Funcionamiento:</h4>
            <ol>
                <li>Configura headers de seguridad estándar</li>
                <li>Implementa políticas CSP</li>
                <li>Activa protecciones del navegador</li>
                <li>Previene ataques como clickjacking</li>
            </ol>
        </div>
        <pre><code>
public class SecurityHeaders {
    public static void addSecurityHeaders(HttpServletResponse response) {
        // Prevenir clickjacking
        response.setHeader("X-Frame-Options", "DENY");
        
        // Activar protección XSS en navegadores modernos
        response.setHeader("X-XSS-Protection", "1; mode=block");
        
        // Prevenir MIME-sniffing
        response.setHeader("X-Content-Type-Options", "nosniff");
        
        // Política de seguridad de contenido
        response.setHeader("Content-Security-Policy", 
            "default-src 'self'; " +
            "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +
            "style-src 'self' 'unsafe-inline';"
        );
        
        // HSTS
        response.setHeader("Strict-Transport-Security",
            "max-age=31536000; includeSubDomains");
        
        // Referrer Policy
        response.setHeader("Referrer-Policy", 
            "strict-origin-when-cross-origin");
        
        // Características del navegador
        response.setHeader("Permissions-Policy",
            "camera=(), microphone=(), geolocation=()");
    }
}
        </code></pre>
    </div>

    <div class="warning">
        <h3>Mejores Prácticas de Seguridad</h3>
        <ul>
            <li>Validar todas las entradas de usuario</li>
            <li>Usar HTTPS en producción</li>
            <li>Implementar el principio de mínimo privilegio</li>
            <li>Mantener las dependencias actualizadas</li>
            <li>Realizar auditorías de seguridad regulares</li>
            <li>Implementar límites de rate y timeout</li>
            <li>Usar almacenamiento seguro para credenciales</li>
            <li>Implementar logging y monitoreo</li>
            <li>Mantener copias de seguridad cifradas</li>
        </ul>
    </div>

    <div class="container">
        <h3>Lista de Verificación de Seguridad</h3>
        <table>
            <tr>
                <th>Categoría</th>
                <th>Verificación</th>
                <th>Prioridad</th>
            </tr>
            <tr>
                <td>Autenticación</td>
                <td>Implementar MFA</td>
                <td>Alta</td>
            </tr>
            <tr>
                <td>Autorización</td>
                <td>Validar permisos en cada solicitud</td>
                <td>Alta</td>
            </tr>
            <tr>
                <td>Datos</td>
                <td>Cifrar datos sensibles</td>
                <td>Alta</td>
            </tr>
            <tr>
                <td>Sesiones</td>
                <td>Implementar timeout</td>
                <td>Media</td>
            </tr>
            <tr>
                <td>Validación</td>
                <td>Sanitizar entradas</td>
                <td>Alta</td>
            </tr>
            <tr>
                <td>Logging</td>
                <td>Auditar acciones críticas</td>
                <td>Media</td>
            </tr>
        </table>
    </div>
    
    <div class="importante">
        <h3>Dependencias Maven</h3>
        <pre><code>
&lt;!-- Para validación y sanitización --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.owasp.encoder&lt;/groupId&gt;
    &lt;artifactId&gt;encoder&lt;/artifactId&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Para logging seguro --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.36&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Para manejo de sesiones --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
    &lt;artifactId&gt;guava&lt;/artifactId&gt;
    &lt;version&gt;31.1-jre&lt;/version&gt;
&lt;/dependency&gt;
        </code></pre>
    </div>
</body>
</html>